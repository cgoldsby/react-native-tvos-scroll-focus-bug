diff --git a/node_modules/react-native/React/Fabric/Mounting/ComponentViews/ScrollView/RCTScrollViewComponentView.mm b/node_modules/react-native/React/Fabric/Mounting/ComponentViews/ScrollView/RCTScrollViewComponentView.mm
index 3304c61..c35dc2b 100644
--- a/node_modules/react-native/React/Fabric/Mounting/ComponentViews/ScrollView/RCTScrollViewComponentView.mm
+++ b/node_modules/react-native/React/Fabric/Mounting/ComponentViews/ScrollView/RCTScrollViewComponentView.mm
@@ -1030,18 +1030,20 @@ - (void)didUpdateFocusInContext:(UIFocusUpdateContext *)context
         [self sendBlurNotification];
         [self removeSwipeGestureRecognizers];
         [self resignFirstResponder];
-        // if we leave the scroll view and go up, then scroll to top; if going down,
-        // scroll to bottom
-        // Similarly for left and right
+        // If scrolling is enabled:
+        // - Scroll to the top when moving up and to the bottom when moving down.
+        // - Similarly, scroll to the left when moving left and to the right when moving right.
         RCTEnhancedScrollView *scrollView = (RCTEnhancedScrollView *)_scrollView;
-        if (context.focusHeading == UIFocusHeadingUp && scrollView.snapToStart) {
-            [self swipeVerticalScrollToOffset:0.0];
-        } else if(context.focusHeading == UIFocusHeadingDown && scrollView.snapToEnd) {
-            [self swipeVerticalScrollToOffset:scrollView.contentSize.height];
-        } else if(context.focusHeading == UIFocusHeadingLeft && scrollView.snapToStart) {
-            [self swipeHorizontalScrollToOffset:0.0];
-        } else if(context.focusHeading == UIFocusHeadingRight && scrollView.snapToEnd) {
-            [self swipeHorizontalScrollToOffset:scrollView.contentSize.width];
+        if (scrollView.isScrollEnabled) {
+            if (context.focusHeading == UIFocusHeadingUp && scrollView.snapToStart) {
+                [self scrollToVerticalOffset:0.0];
+            } else if(context.focusHeading == UIFocusHeadingDown && scrollView.snapToEnd) {
+                [self scrollToVerticalOffset:scrollView.contentSize.height];
+            } else if(context.focusHeading == UIFocusHeadingLeft && scrollView.snapToStart) {
+                [self scrollToHorizontalOffset:0.0];
+            } else if(context.focusHeading == UIFocusHeadingRight && scrollView.snapToEnd) {
+                [self scrollToHorizontalOffset:scrollView.contentSize.width];
+            }
         }
     }
 }
@@ -1100,19 +1102,26 @@ - (void)handleTVNavigationEventNotification:(NSNotification *)notif
 
 - (BOOL)shouldUpdateFocusInContext:(UIFocusUpdateContext *)context
 {
+    // If the previously focused item is this view and scrolling is disabled, defer to the superclass
+    if (context.previouslyFocusedItem == self && !self.scrollView.isScrollEnabled) {
+        return [super shouldUpdateFocusInContext:context];
+    }
+
     BOOL isHorizontal = _scrollView.contentSize.width > self.frame.size.width;
     // Keep focus inside the scroll view till the end of the content
     if (isHorizontal) {
-        if ((context.focusHeading == UIFocusHeadingLeft && self.scrollView.contentOffset.x > 0)
-            || (context.focusHeading == UIFocusHeadingRight && self.scrollView.contentOffset.x < self.scrollView.contentSize.width - self.scrollView.visibleSize.width)
-        ) {
-            return [UIFocusSystem environment:self containsEnvironment:context.nextFocusedItem];
+        BOOL isMovingLeft = (context.focusHeading == UIFocusHeadingLeft && self.scrollView.contentOffset.x > 0);
+        BOOL isMovingRight = (context.focusHeading == UIFocusHeadingRight && self.scrollView.contentOffset.x < self.scrollView.contentSize.width - MAX(self.scrollView.visibleSize.width, 1));
+
+        if (isMovingLeft || isMovingRight) {
+            return (context.nextFocusedItem && [UIFocusSystem environment:self containsEnvironment:context.nextFocusedItem]);
         }
     } else {
-        if ((context.focusHeading == UIFocusHeadingUp && self.scrollView.contentOffset.y > 0)
-            || (context.focusHeading == UIFocusHeadingDown && self.scrollView.contentOffset.y < self.scrollView.contentSize.height - self.scrollView.visibleSize.height)
-        ) {
-            return [UIFocusSystem environment:self containsEnvironment:context.nextFocusedItem];
+        BOOL isMovingUp = (context.focusHeading == UIFocusHeadingUp && self.scrollView.contentOffset.y > 0);
+        BOOL isMovingDown = (context.focusHeading == UIFocusHeadingDown && self.scrollView.contentOffset.y < self.scrollView.contentSize.height - MAX(self.scrollView.visibleSize.height, 1));
+
+        if (isMovingUp || isMovingDown) {
+            return (context.nextFocusedItem && [UIFocusSystem environment:self containsEnvironment:context.nextFocusedItem]);
         }
     }
 
@@ -1157,13 +1166,23 @@ - (NSTimeInterval)swipeDuration
     return duration;
 }
 
-- (void)swipeVerticalScrollToOffset:(CGFloat)yOffset
+- (void)scrollToVerticalOffset:(CGFloat)yOffset
 {
     _blockFirstTouch = NO;
     dispatch_async(dispatch_get_main_queue(), ^{
         CGFloat limitedOffset = yOffset;
+
+        // Ensure content size and visible size are non-negative
+        CGFloat contentHeight = MAX(self.scrollView.contentSize.height, 0.0);
+        CGFloat visibleHeight = MAX(self.scrollView.visibleSize.height, 0.0);
+
+        // Compute the maximum offset, ensuring it's non-negative
+        CGFloat maxOffset = MAX(contentHeight - visibleHeight, 0.0);
+
+        // Clamp the offset within valid bounds
         limitedOffset = MAX(limitedOffset, 0.0);
-        limitedOffset = MIN(limitedOffset, self.scrollView.contentSize.height - self.scrollView.visibleSize.height);
+        limitedOffset = MIN(limitedOffset, maxOffset);
+
         [UIView animateWithDuration:[self swipeDuration] animations:^{
             self.scrollView.contentOffset =
                 CGPointMake(self.scrollView.contentOffset.x, limitedOffset);
@@ -1171,13 +1190,23 @@ - (void)swipeVerticalScrollToOffset:(CGFloat)yOffset
     });
 }
 
-- (void)swipeHorizontalScrollToOffset:(CGFloat)xOffset
+- (void)scrollToHorizontalOffset:(CGFloat)xOffset
 {
     _blockFirstTouch = NO;
     dispatch_async(dispatch_get_main_queue(), ^{
         CGFloat limitedOffset = xOffset;
+
+        // Ensure content size and visible size are non-negative
+        CGFloat contentWidth = MAX(self.scrollView.contentSize.width, 0.0);
+        CGFloat visibleWidth = MAX(self.scrollView.visibleSize.width, 0.0);
+
+        // Compute the maximum offset, ensuring it's non-negative
+        CGFloat maxOffset = MAX(contentWidth - visibleWidth, 0.0);
+
+        // Clamp the offset within valid bounds
         limitedOffset = MAX(limitedOffset, 0.0);
-        limitedOffset = MIN(limitedOffset, self.scrollView.contentSize.width - self.scrollView.visibleSize.width);
+        limitedOffset = MIN(limitedOffset, maxOffset);
+
         [UIView animateWithDuration:[self swipeDuration] animations:^{
             self.scrollView.contentOffset =
                 CGPointMake(limitedOffset, self.scrollView.contentOffset.y);
@@ -1187,30 +1216,46 @@ - (void)swipeHorizontalScrollToOffset:(CGFloat)xOffset
 
 - (void)swipedUp
 {
+    if (!self.scrollView.scrollEnabled) {
+        return;
+    }
+
     CGFloat newOffset = self.scrollView.contentOffset.y - [self swipeVerticalInterval];
     // NSLog(@"Swiped up to %f", newOffset);
-    [self swipeVerticalScrollToOffset:newOffset];
+    [self scrollToVerticalOffset:newOffset];
 }
 
 - (void)swipedDown
 {
+    if (!self.scrollView.scrollEnabled) {
+        return;
+    }
+
     CGFloat newOffset = self.scrollView.contentOffset.y + [self swipeVerticalInterval];
     // NSLog(@"Swiped down to %f", newOffset);
-    [self swipeVerticalScrollToOffset:newOffset];
+    [self scrollToVerticalOffset:newOffset];
 }
 
 - (void)swipedLeft
 {
+    if (!self.scrollView.scrollEnabled) {
+        return;
+    }
+
     CGFloat newOffset = self.scrollView.contentOffset.x - [self swipeHorizontalInterval];
     // NSLog(@"Swiped left to %f", newOffset);
-    [self swipeHorizontalScrollToOffset:newOffset];
+    [self scrollToHorizontalOffset:newOffset];
 }
 
 - (void)swipedRight
 {
+    if (!self.scrollView.scrollEnabled) {
+        return;
+    }
+
     CGFloat newOffset = self.scrollView.contentOffset.x + [self swipeHorizontalInterval];
     // NSLog(@"Swiped right to %f", newOffset);
-    [self swipeHorizontalScrollToOffset:newOffset];
+    [self scrollToHorizontalOffset:newOffset];
 }
 
 - (void)addSwipeGestureRecognizers
diff --git a/node_modules/react-native/React/Views/ScrollView/RCTScrollView.m b/node_modules/react-native/React/Views/ScrollView/RCTScrollView.m
index e9db4d2..24538f5 100644
--- a/node_modules/react-native/React/Views/ScrollView/RCTScrollView.m
+++ b/node_modules/react-native/React/Views/ScrollView/RCTScrollView.m
@@ -1018,19 +1018,20 @@ - (void)didUpdateFocusInContext:(UIFocusUpdateContext *)context
         [self sendBlurNotification];
         [self removeSwipeGestureRecognizers];
         [self resignFirstResponder];
-        // if we leave the scroll view and go up, then scroll to top; if going down,
-        // scroll to bottom
-        // Similarly for left and right
-        if (context.focusHeading == UIFocusHeadingUp && self.snapToStart) {
-            [self scrollToVerticalOffset:0.0];
-        } else if(context.focusHeading == UIFocusHeadingDown && self.snapToEnd) {
-            [self scrollToVerticalOffset:self.scrollView.contentSize.height];
-        } else if(context.focusHeading == UIFocusHeadingLeft && self.snapToStart) {
-            [self scrollToHorizontalOffset:0.0];
-        } else if(context.focusHeading == UIFocusHeadingRight && self.snapToEnd) {
-            [self scrollToHorizontalOffset:self.scrollView.contentSize.width];
+        // If scrolling is enabled:
+        // - Scroll to the top when moving up and to the bottom when moving down.
+        // - Similarly, scroll to the left when moving left and to the right when moving right.
+        if (self.scrollView.isScrollEnabled) {
+            if (context.focusHeading == UIFocusHeadingUp && self.snapToStart) {
+                [self scrollToVerticalOffset:0.0];
+            } else if(context.focusHeading == UIFocusHeadingDown && self.snapToEnd) {
+                [self scrollToVerticalOffset:self.scrollView.contentSize.height];
+            } else if(context.focusHeading == UIFocusHeadingLeft && self.snapToStart) {
+                [self scrollToHorizontalOffset:0.0];
+            } else if(context.focusHeading == UIFocusHeadingRight && self.snapToEnd) {
+                [self scrollToHorizontalOffset:self.scrollView.contentSize.width];
+            }
         }
-
     }
 }
 
@@ -1086,18 +1087,25 @@ - (void)handleTVNavigationEventNotification:(NSNotification *)notif
 
 - (BOOL)shouldUpdateFocusInContext:(UIFocusUpdateContext *)context
 {
+    // If the previously focused item is this view and scrolling is disabled, defer to the superclass
+    if (context.previouslyFocusedItem == self && !self.scrollView.isScrollEnabled) {
+        return [super shouldUpdateFocusInContext:context];
+    }
+
     // Keep focus inside the scroll view till the end of the content
     if ([self isHorizontal:self.scrollView]) {
-        if ((context.focusHeading == UIFocusHeadingLeft && self.scrollView.contentOffset.x > 0)
-            || (context.focusHeading == UIFocusHeadingRight && self.scrollView.contentOffset.x < self.scrollView.contentSize.width - self.scrollView.visibleSize.width)
-        ) {
-            return [UIFocusSystem environment:self containsEnvironment:context.nextFocusedItem];
+        BOOL isMovingLeft = (context.focusHeading == UIFocusHeadingLeft && self.scrollView.contentOffset.x > 0);
+        BOOL isMovingRight = (context.focusHeading == UIFocusHeadingRight && self.scrollView.contentOffset.x < self.scrollView.contentSize.width - MAX(self.scrollView.visibleSize.width, 1));
+
+        if (isMovingLeft || isMovingRight) {
+            return (context.nextFocusedItem && [UIFocusSystem environment:self containsEnvironment:context.nextFocusedItem]);
         }
     } else {
-        if ((context.focusHeading == UIFocusHeadingUp && self.scrollView.contentOffset.y > 0)
-            || (context.focusHeading == UIFocusHeadingDown && self.scrollView.contentOffset.y < self.scrollView.contentSize.height - self.scrollView.visibleSize.height)
-        ) {
-            return [UIFocusSystem environment:self containsEnvironment:context.nextFocusedItem];
+        BOOL isMovingUp = (context.focusHeading == UIFocusHeadingUp && self.scrollView.contentOffset.y > 0);
+        BOOL isMovingDown = (context.focusHeading == UIFocusHeadingDown && self.scrollView.contentOffset.y < self.scrollView.contentSize.height - MAX(self.scrollView.visibleSize.height, 1));
+
+        if (isMovingUp || isMovingDown) {
+            return (context.nextFocusedItem && [UIFocusSystem environment:self containsEnvironment:context.nextFocusedItem]);
         }
     }
 
@@ -1144,8 +1152,18 @@ - (void)scrollToVerticalOffset:(CGFloat)yOffset
     _blockFirstTouch = NO;
     dispatch_async(dispatch_get_main_queue(), ^{
         CGFloat limitedOffset = yOffset;
+
+        // Ensure content size and visible size are non-negative
+        CGFloat contentHeight = MAX(self.scrollView.contentSize.height, 0.0);
+        CGFloat visibleHeight = MAX(self.scrollView.visibleSize.height, 0.0);
+
+        // Compute the maximum offset, ensuring it's non-negative
+        CGFloat maxOffset = MAX(contentHeight - visibleHeight, 0.0);
+
+        // Clamp the offset within valid bounds
         limitedOffset = MAX(limitedOffset, 0.0);
-        limitedOffset = MIN(limitedOffset, self.scrollView.contentSize.height - self.scrollView.visibleSize.height);
+        limitedOffset = MIN(limitedOffset, maxOffset);
+
         [UIView animateWithDuration:[self swipeDuration] animations:^{
             self.scrollView.contentOffset =
               CGPointMake(self.scrollView.contentOffset.x, limitedOffset);
@@ -1158,8 +1176,18 @@ - (void)scrollToHorizontalOffset:(CGFloat)xOffset
     _blockFirstTouch = NO;
     dispatch_async(dispatch_get_main_queue(), ^{
         CGFloat limitedOffset = xOffset;
+
+        // Ensure content size and visible size are non-negative
+        CGFloat contentWidth = MAX(self.scrollView.contentSize.width, 0.0);
+        CGFloat visibleWidth = MAX(self.scrollView.visibleSize.width, 0.0);
+
+        // Compute the maximum offset, ensuring it's non-negative
+        CGFloat maxOffset = MAX(contentWidth - visibleWidth, 0.0);
+
+        // Clamp the offset within valid bounds
         limitedOffset = MAX(limitedOffset, 0.0);
-        limitedOffset = MIN(limitedOffset, self.scrollView.contentSize.width - self.scrollView.visibleSize.width);
+        limitedOffset = MIN(limitedOffset, maxOffset);
+
         [UIView animateWithDuration:[self swipeDuration] animations:^{
             self.scrollView.contentOffset =
               CGPointMake(limitedOffset, self.scrollView.contentOffset.y);
